=== SPI

==== Request flow

REST uses standard HTTP actions POST / GET / PUT / DELETE to perform Create, Read, Update and Delete operations.

LiveOak handles a request by traversing a chain of Resources from the top RootResource down to the collection resource
targeted by the URI, calling readMember(id) on each next child, and finally performing action specific handling on the last
child Resource - let's call it a _target Resource_.

The following request:

    GET /{app_name}/{resource_root}/{collection}/{id}

is handled by looking up an application corresponding to _{app_name}_ in the application registry, then using it to retrieve
a RootResource corresponding to _{resource_root}_, and then calling readMember(_{collection}_) on it. If that method returns
a Resource instance the processing continues by calling readMember(_{id}_), otherwise it ends with an error status.

When a Resource corresponding to the last URI component is reached, any action specific processing is performed.

While LiveOak Container is primarily a JSON oriented REST container it also supports handling of non-json documents in which
case a targeted Resource has to implement the BinaryResource interface.

When processing a request, a Resource should use the RequestContext object to take into account ReturnFields, Pagination,
Sorting, and other context information, to apply proper constraints before performing any state change, and during response generation.

===== POST

    POST /{collection}

LiveOak maps the HTTP POST action to a Create operation, calling createMember() on the target Resource.

A posted JSON document can specify an id field with a unique new value which should be used by targeted resource, unless
a Resource implementation only supports autogenerated ids, in which case NOT_ACCEPTABLE error should be returned.
If no id field is specified, a targeted resource should generate a new unique id for the item, unless a Resource
implementation doesn't support generating ids, in which case it should again return NOT_ACCEPTABLE.

If an id is specified, and an item with the same id exists already, then a Resource should return the
RESOURCE_ALREADY_EXISTS error. In other words - POST, and consequently createMember() should not be used to update
an existing item.

If the posted JSON contains fields that can't be handled by the targeted Resource, it should result in a NOT_ACCEPTABLE error.

Method createMember() should finish with a call to Responder.resourceCreated(), passing it a Resource that will - when
readProperties() is invoked on it - produce a full state of the resource including any default or autogenerated fields.

After successful creation the new item should be available at

    GET /{collection}/{id}

If a targeted URI represents a resource item that can't have children, then a Resource should return CREATE_NOT_SUPPORTED.

    POST /{collection}/{id}

should produce an error, when the targeted resource doesn't support children.

POST on a collection with body containing members should set collection properties. It is up to Resource to decide how
to treat any sent _members_.

===== PUT

    PUT /{collection}/{id}

LiveOak maps the HTTP PUT action to an Update operation, calling updateProperties() on the target Resource.

A posted JSON document represents a full new state of the updated item.
Since the targeted item is identified by URI, an _id_ field is optional. If present it should be equal to the last URI segment.

Targeted resource should check for mismatch and return NOT_ACCEPTABLE.

(TODO could container perform this check for us?)

If the posted JSON contains fields that can't be handled by the targeted Resource, it should result in a NOT_ACCEPTABLE error.

LiveOak has a mechanism for when a resource targeted for Update does not yet exist - it will reroute handling to call
createMember() on the last parent Resource. This way, PUT can be used to not only update existing, but to also create new
resource items.

    POST /{collection}

    PUT /{collection}/{id}

The above two actions have the same effect. PUT can only be used when clients are allowed to specify id for a new item.

A posted JSON document may not contain fields which can have their value autogenerated. It should always be treated as
representing a full new state of the object so any autogenerated values should never be based on previous state of the item.

If a JSON document contains _members_ it is up to a Resource how to handle them.

===== GET

    GET /{collection}/{id}

LiveOak maps the HTTP GET action to a Read operation, calling readProperties() on the target Resource, followed by a
readMembers() call on the same Resource.

If the targeted resource represents a collection, it should implement readMembers() method to return Resource instances
representing child items. Pagination, Sorting, and possibly some query parameters from ResourceParams should be used to
only return requested items in proper order.

It depends on ReturnFields if member Resources will have their readProperties(), and readMembers() invoked or not.
A Resource should take ReturnFields into account when performing a query against any data store to avoid retrieving
unnecessary data, and thus reduce processing time.

The Read operation has to be idempotent - meaning that it doesn't perform any update / create / delete operations - and
has no stateful side effects.

===== DELETE

    DELETE /{collection}/{id}

LiveOak maps the HTTP DELETE action to a Delete operation, calling delete() on the target Resource.

After a successful Delete, targeting the same URI for Read should result in a NO_SUCH_RESOURCE error.
----
GET /{collection}/{id}

HTTP/1.1 404 Not Found
----

= Resource Developer's Guide
:awestruct-layout: two-column
:toc:
:toc-placement!:

toc::[]

This document provides guidance on how to use LiveOak Resource SPI to implement a REST API that behaves the same way across the different resources.


== Request flow

REST uses standard HTTP actions POST / GET / PUT / DELETE to perform Create, Read, Update and Delete operations.

LiveOak handles a request by traversing a chain of Resources from top RootResource down to the collection resource targeted by URI, calling readMember(id) on each next child, and finally performing action specific handling on the last child Resource - let's call it a _target Resource_.

The following request:

    GET /{app_name}/{resource_root}/{collection}/{id}

is handled by looking up an application corresponding to _{app_name}_ in application registry, then using it to retrieve a RootResource corresponding to _{resource_root}_, and then calling readMember(_{collection}_) on it. If that method returns a Resource instance the processing continues by calling readMember(_{id}_), otherwise it ends with an error status.

When a Resource corresponding to the last URI component is reached, an action specific processing is performed.

While LiveOak Container is primarily a JSON oriented REST container it also supports handling of non-json documents in which case a targeted Resource has to implement BinaryResource interface.

When processing a request a Resource should use RequestContext object to take into account ReturnFields, Pagination, Sorting, and other context information to apply proper constraints before performing any state change, and during response generation.



=== POST

    POST /{collection}

LiveOak maps HTTP POST action to Create operation, calling createMember() on the target Resource.

A posted JSON document can specify an id field with unique new value which should be used by targeted resource, unless a Resource implementation only supports autogenerated ids in which case NOT_ACCEPTABLE error should be returned.
If no id field is specified a targeted resource should generate a new unique id for the new item, unless a Resource implementation doesn't support generating ids in which case it should again return NOT_ACCEPTABLE.

If an id is specified, and an item with the same id exists already, then Resource should return RESOURCE_ALREADY_EXISTS error. In other words - POST, and consequently createMember() should not be used to update an existing item. 

If posted JSON contains fields that can't be handled by targeted Resource that should result in a NOT_ACCEPTABLE error.

Method createMember() should complete with a call to Responder.resourceRead(), passing it a Resource that will - when readProperties() is invoked on it - produce a full state of the resource including any default or autogenerated fields.

After successful create the new item should be available at

    GET /{collection}/{id}


If targeted URI represents a resource item that can't have children, then Resource should return CREATE_NOT_SUPPORTED.

    POST /{collection}/{id}

should produce an error, when targeted resource doesn't support children.

POST on a collection with body containing members should set collection properties. It is up to Resource to decide how to treat any sent _members_.


=== PUT

    PUT /{collection}/{id}
    
LiveOak maps HTTP PUT action to Update operation, calling updateProperties() on the target Resource.

A posted JSON document represents a full new state of the updated item.
Since the targeted item is identified by URI an _id_ field is optional. If present it should be equal to last URI segment.

Targeted resource should check for mismatch and return NOT_ACCEPTABLE.

(TODO could container perform this check for us?)

If posted JSON contains fields that can't be handled by targeted Resource that should result in a NOT_ACCEPTABLE error.

LiveOak has a mechanism for when a resource targeted for Update does not yet exist - it will reroute handling to call createMember() on the last parent Resource.
This way PUT can be used to not only update existing, but to also create new resource items.

    POST /{collection}
    
    PUT /{collection}/{id}

The above two actions have the same effect. PUT can only be used when clients are allowed to specify id for a new item.


A posted JSON document may not contain fields which can have their value autogenerated.
It should always be treated as representing a full new state of the object so any autogenerated values should never be based on previous state of the item. 

If JSON document contains _members_ it is up to a Resource how to handle them.


=== GET

    GET /{collection}/{id}

LiveOak maps HTTP GET action to Read operation, calling readProperties() on the target Resource, followed by readMembers() call on the same Resource.

If targeted resource represents a collection, it should implement readMembers() method to return Resource instances representing child items.
Pagination, Sorting, and possibly some query parameters from ResourceParams should be used to only return requested items in proper order.

It depends on ReturnFields if member Resources will have their readProperties(), and readMembers() invoked or not.
A Resource should take ReturnFields into account when performing a query against any data store to avoid retrieving unnecessary data, and thus reduce processing time.

Read operation has to be idempotent - meaning that it doesn't perform any update / create / delete operations - and have no stateful side effects.


=== DELETE

    DELETE /{collection}/{id}
    
LiveOak maps HTTP DELETE action to Delete operation, calling delete() on the target Resource.

After a successful Delete, targeting the same URI for Read should result in NO_SUCH_RESOURCE error.
----
GET /{collection}/{id}
    
HTTP/1.1 404 Not Found
----

